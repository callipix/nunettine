package kr.or.ddit.board.pro_story.controller;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartHttpServletRequest;

import kr.or.ddit.board.pro_story.vo.ProStoryBbscttVO;
import lombok.extern.slf4j.Slf4j;
import net.coobird.thumbnailator.Thumbnailator;

@Slf4j
@Controller
public class CkUploadController {

	@Autowired
	String uploadDirectCk;

	@Autowired
	String uploadFolder;
	
	//ckeditor이미지 업로드 , data전송 -> ResponseBody어노테이션 추가(객체화)
	@ResponseBody
	@PostMapping("/upload/uploads2")
	public Map<String , Object> uploads(MultipartHttpServletRequest request) throws IllegalStateException, IOException{
		
		// request에 이미지 객체가 담져겨 있다
		// ckeditor 에서 파일을 보낼 때 upload : [파일] 형식으로 해서 넘어오기 때문에 upload라는 키의 밸류를 받아서 uploadFile에 저장함
		// 열기 누르는 순간
		MultipartFile uploadFile = request.getFile("upload");
		log.info("uploads -> uploadFile : " + uploadFile);
		
		// 파일의 오리지널 명
		String originalFileName = uploadFile.getOriginalFilename();
		log.info("uploads -> originalFileName : " + originalFileName);
		
		// 파일의 확장자(개똥이.jpg)
		String ext = originalFileName.substring(originalFileName.indexOf("."));
		log.info("ext : " + ext);	// .jpg
		
		String newFileName = UUID.randomUUID() + ext;	// sadlfkjsafd.jpg
		
		// 이미지를 현재 경로와 연관된 파일에 저장하기 위해 현재 경로를 알아냄
	    // String realPath = request.getServletContext().getRealPath("/");
		
	    String url = request.getRequestURL().toString();
	    log.info("uploads->url(bef) 업로드전 : " + url);
	    
	    // http://localhost/
	    // http://192.168.93.73/
	    
	    url = url.substring(0, url.indexOf("/", 7));
	    log.info("uploads->url(aft) 업로드후: " + url);
		
		// 업로드 폴더에 저장
		// 물리적 저장 경로.../upload + "\\" + sadlfkjsafd.jpg
		
//	    String savePath = this.uploadFolderDirect + "\\" + newFileName;
	    String savePath = this.uploadDirectCk + "\\" + newFileName;
		log.info("uploads -> savePath : " + savePath);
		
		// 웹 경로
		String uploadPath = this.uploadFolder +"\\" + newFileName;
		log.info("업로드 경로 : " + uploadPath);
		log.info("웹경로 : " + uploadPath);
		
		// 설계
		File file = new File(savePath);
		log.info("설계 -> file : " + savePath);
		
		// 파일 업로드 처리
		uploadFile.transferTo(file);
		
		Map<String, Object>map = new HashMap<>();
		map.put("uploaded" , true);
		map.put("url" , url + "\\" + this.uploadFolder);
		// map : {uploaded = true  , url=http://localhost/resources/upload/asdasdasd~~.jpg}
		log.info("uploads -> map : " + map);
		
		return map;
		
	}
	
	public String imgThumb(MultipartHttpServletRequest request) {
		
		ProStoryBbscttVO itemVO = new ProStoryBbscttVO();
		
		MultipartFile multipartFile = itemVO.getUploadFile();
		
		log.info("이미지 파일명 : " + multipartFile.getOriginalFilename());
		log.info("이미지 크기 : " + multipartFile.getSize());
		
		// MIME(Multipurpose Internet Mail Extensions , 미디어타입) : 문서, 파일 또는 바이트 집합의 성격과 형식(확장자)
		// .jpg / .jpeg 의 MIME타입 : image/jpeg
		
		log.info("MIME 타입 : " + multipartFile.getContentType());
		
		//연월일 폴더 생성 설계
		// ... \\upload \\ 2024 \\ 01 \\ 30
		
		File uploadPath = new File(uploadFolder , getFolder());
		
		//연월일 폴더 생성 실행
		if(uploadPath.exists() == false) {
			uploadPath.mkdirs();
		}
		String uploadFileName =  multipartFile.getOriginalFilename();
		// 파일명 중복 방지*
		//같은 날 같은 이미지 업로드 시 파일명 중복 방지 시작----------------
        //java.util.UUID => 랜덤값 생성
        
		UUID uuid = UUID.randomUUID();
        
		//원래의 파일 이름과 구분하기 위해 _를 붙임(sdafjasdlfksadj_개똥이.jpg)
        uploadFileName = uuid.toString() + "_" + uploadFileName;
        //같은 날 같은 이미지 업로드 시 파일 중복 방지 끝----------------
				
		// 설계
		// , 의 역할 : \\
		// uploadFolder : ...upload\\2024\\01\\30 + \\ + 개똥이.jpg
//		File saveFile = new File(uploadFolder + "\\" + multipartFile.getOriginalFilename());
//		↕↕↕↕↕↕↕ 동일
		File saveFile = new File(uploadPath , uploadFileName);

		//파일 복사 실행(설계대로)
		//스프링파일객체.transferTo(설계)
		// 실제 파일을 복사하기 때문에 try-catch로 예외처리 해야한다
		try {
			
			multipartFile.transferTo(saveFile);
			
			// 썸네일 처리
			// 이미지만 가능하기때문에 이미지인지 사전체크
			if(checkImageType(saveFile)) {	// 이미지가 맞다면
				// 설계
				FileOutputStream thumbnail = new FileOutputStream(new File(uploadPath , "s_"+ uploadFileName) );
			//썸네일 생성 -> 기존 이미지를 100*100 사이즈로 축소시킨다
			Thumbnailator.createThumbnail(multipartFile.getInputStream() , thumbnail , 100 , 100);
			thumbnail.close();
			};
			
			// ITEM 테이블에 반영
			//ItemVO[itemId=0,itemName=삼성태블릿,price=120000,description=쓸만함
      //        pictureUrl=null,uploadFile=파일객체]
			itemVO.setProStoryBbscttNo(0);//자동 데이터 생성
			// 웹경로
			// getFolder().replace("\\" , "/") : 2024/01/30
			// /2024/01/30 sdafjasdlfksadj_개똥이.jpg
			itemVO.setProStoryBbscttThumbPhoto(
					"/" + getFolder().replace("\\" , "/") + "/"	+ uploadFileName
					);
			// uuid가 적용된 파일명
			
			log.info("registerPost -> itemVO : " + itemVO);
			
//			int result = this.itemService.registerPost(itemVO);
//			log.info("registerPost -> result : " + result);
		} catch (IllegalStateException | IOException e) {
			log.error(e.getMessage());
		}
		
		return "";
	}
	
	 public boolean checkImageType(File file) {
	      //MIME(Multipurpose Internet Mail Extensions) : 문서, 파일 또는 바이트 집합의 성격과 형식. 표준화
	      //MIME 타입 알아냄. .jpeg / .jpg의 MIME타입 : image/jpeg
	      String contentType;
	      try {
	         contentType = Files.probeContentType(file.toPath());
	         log.info("contentType : " + contentType);
	         //image/jpeg는 image로 시작함->true
	         return contentType.startsWith("image");
	      } catch (IOException e) {
	         e.printStackTrace();
	      }
	      //이 파일이 이미지가 아닐 경우
	      return false;
	   }  
	 
	 public String getFolder() {
	      // 2024-01-30 형식(format) 지정
	      // 간단한 날짜 형식
	      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
	      // 날짜 객체 생성(java.util 패키지)
	      Date date = new Date();
	      // 2024-01-30 -> 2024\\01\\30
	      String str = sdf.format(date);
	      
	      return str.replace("-", File.separator);
	      
	      // file.separator -> 파일 이름 구분자 (2024\\01\\30)
	   }
	
}
